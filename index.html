<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="道阻且长,行则将至">
<meta property="og:type" content="website">
<meta property="og:title" content="上任鹅城">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="上任鹅城">
<meta property="og:description" content="道阻且长,行则将至">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="马帅傅">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>上任鹅城</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">上任鹅城</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/13/Vue2.x%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/Vue2.x%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">Vue2.x的组件通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-13 17:52:37 / Modified: 18:28:51" itemprop="dateCreated datePublished" datetime="2021-09-13T17:52:37+08:00">2021-09-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2021/09/13/Vue2.x%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的组件通信" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/13/Vue2.x%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/13/Vue2.x%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="父-gt-子"><a href="#父-gt-子" class="headerlink" title="父-&gt;子"></a>父-&gt;子</h4><h5 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h5><p>父组件通过属性的方式给子组件传值，子组件通过props来接受父组件的值。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol>
<li><p>如果传递的是个对象的话，只改变下面的某个属性子组件中是不会响应式更新的，如果子组件需要在数据变化时响应式更新，可以用watch深拷贝deep:true监听到变化；</p>
</li>
<li><p>如果你传进来的是个对象，同时你又需要在子组件中操作传进来的这个数据，那么在父组件中的这个数据也会改变，因为传递的只是个引用，可通过将对象做深拷贝创建一个副本解决这个问题。</p>
</li>
</ol>
<h5 id="可以但不建议的操作"><a href="#可以但不建议的操作" class="headerlink" title="可以但不建议的操作"></a>可以但不建议的操作</h5><ol>
<li><p>直接用ref调用子组件函数直接把数据以参数的形式传给子组件；</p>
</li>
<li><p>$children是一个数组，是直接儿子的集合，不保证顺序，也不是响应式。</p>
</li>
</ol>
<h4 id="子-gt-父"><a href="#子-gt-父" class="headerlink" title="子-&gt;父"></a>子-&gt;父</h4><h5 id="方式-1"><a href="#方式-1" class="headerlink" title="方式"></a>方式</h5><p>子组件通过$emit的操作触发父组件的自定义事件，父组件中监听这个事件并在回调中写相关逻辑。</p>
<h5 id="可以但不建议的操作-1"><a href="#可以但不建议的操作-1" class="headerlink" title="可以但不建议的操作"></a>可以但不建议的操作</h5><ol>
<li><p>可以在子组件中定义一种专供父组件调用的函数，当父组件想要获取子组件数据就直接主动调用ref执行这个函数获取数据；</p>
</li>
<li><p>$parent是当前组件树的根 Vue 实例，如果当前实例没有父实例，此实例将会是其自己。</p>
</li>
</ol>
<h4 id="兄-gt-弟"><a href="#兄-gt-弟" class="headerlink" title="兄-&gt;弟"></a>兄-&gt;弟</h4><h5 id="方式-2"><a href="#方式-2" class="headerlink" title="方式"></a>方式</h5><ol>
<li><p>路由URL参数：把需要跨页面传递的数据放到url后面，跳转到另外页面时获取url字符串获取想要的参数即可。局限性：只适合传递比较小的数据。</p>
</li>
<li><p>EventBus：在组件之外定义一个event-bus.js作为组件间通信的桥梁，也可称之为事件总线。EventBus实现了发布订阅模式，往事件总线里订阅事件用的是on，发布事件用的是emit。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// event-bus.js</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">export const EventBus = new Vue()</span><br></pre></td></tr></table></figure>



<h4 id="祖先-gt-后代"><a href="#祖先-gt-后代" class="headerlink" title="祖先-&gt;后代"></a>祖先-&gt;后代</h4><h5 id="方式-3"><a href="#方式-3" class="headerlink" title="方式"></a>方式</h5><ol>
<li><p>provide/inject，允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>
</li>
<li><p>$attrs：在子组件中添加v-bind=’$​attrs’，就把父组件传来的子组件没props接收的数据全部传到孙组件，子组件和孙组件都可以用this.$attrs获取。</p>
</li>
</ol>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>provide 和 inject 绑定并不是可响应的。如果数据类型是对象Object，其对象的属性还是可响应的，因为对象格式数据存储的是指针而不是数据，操作的是同一个对象。</p>
<h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><h5 id="方式-4"><a href="#方式-4" class="headerlink" title="方式"></a>方式</h5><p>1.Vuex集中状态管理：类似与一个共享数据仓库，所有的组件都可以去操作；</p>
<p>2.localStorage，sessionStorage，cooikes之类的存在本地也能做到组件间的通信。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/13/Vue2.x%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/Vue2.x%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Vue2.x的编译过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-13 16:53:42 / Modified: 16:55:10" itemprop="dateCreated datePublished" datetime="2021-09-13T16:53:42+08:00">2021-09-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2021/09/13/Vue2.x%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的编译过程" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/13/Vue2.x%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/13/Vue2.x%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/11/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Vue2.x的patch方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-11 09:38:33" itemprop="dateCreated datePublished" datetime="2021-09-11T09:38:33+08:00">2021-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-13 11:46:35" itemprop="dateModified" datetime="2021-09-13T11:46:35+08:00">2021-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2021/09/11/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的patch方法" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/11/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/11/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将VNode渲染成真实的DOM</p>
<h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><h5 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h5><p>patch可以理解成打补丁的意思，在patch方法中采用diff算法比较新旧节点，一边比较一边给真实的DOM打补丁。</p>
<h5 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h5><p>diff算法用来比较新旧节点，比较只会在同层级比较，不会跨层级比较，这个是相对于传统diff算法的一个很大提升。</p>
<h6 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h6><ul>
<li><p>判断两节点是否值得比较（sameVNode），值得比较则执行patchVNode方法。这个方法做了如下事情：</p>
<ol>
<li><p>找到当前oldVNode对应的真实节点，称为el；</p>
</li>
<li><p>判断VNode和oldVNode是否指向同一个对象，如果是，直接返回；</p>
</li>
<li><p>如果两者都是文本节点且不相等，将el的文本节点设置为VNode的文本节点；</p>
</li>
<li><p>如果oldVNode有子节点而VNode没有，删除el的子节点；</p>
</li>
<li><p>如果oldVNode没有子节点而VNode有，则将VNode的子节点生成真实节点，添加到el；</p>
</li>
<li><p>如果两者都有子节点，则通过updateChildren函数比较子节点。由于updateChildren方法是diff中相对复杂的一部分，拎出来单独分析一下。</p>
</li>
</ol>
</li>
<li><p>不值得比较则用VNode替换oldVNode。具体流程如下：</p>
<ol>
<li>找到当前oldVNode对应的真实节点以及该节点的父节点；</li>
<li>根据VNode生成新节点；</li>
<li>将新节点添加到父节点；</li>
<li>移除旧节点。</li>
</ol>
</li>
</ul>
<h5 id="updateChildren方法"><a href="#updateChildren方法" class="headerlink" title="updateChildren方法"></a>updateChildren方法</h5><p>updateChildren方法用来给新旧VNode都有子节点的情况打补丁。可以将新旧VNode理解成两个数组，以旧数组为基础，通过删除、移动、插入的方式，将旧数组的值转换成新数组的值。</p>
<p>⚠️这里的值指的不是两个数组所在的存储地址，只是数组项的值。而且每次删除、移动、插入的时候都会操作真实DOM。</p>
<h6 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h6><p>旧数组：[oldS，…，oldE]</p>
<p>新数组：[S, …, E]</p>
<p>其中oldS和oldE是待匹配旧节点的开始子节点和结束子节点，S和E是待匹配新节点的开始子节点和结束子节点。这里的oldS、oldE、S和E在diff过程中是会变的，可以理解成一个变量或者一个代号。因为在diff过程中，如果新旧子节点已经匹配过了，会从待匹配的新旧节点列表中移除。</p>
<p> 可以分为5个匹配方式来对比是否是sameVNode，来按顺序完成匹配：</p>
<ol>
<li><p>旧首新首对比：匹配成功会将旧结束子节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配的新旧节点列表中的开始子节点；</p>
</li>
<li><p>旧尾旧尾对比：匹配成功会将旧开始子节点移动到真实DOM中目前可供选择位置的最后，因为不能影响到已经patch好的子节点位置，然后移除待匹配的新旧节点列表中的结束子节点；</p>
</li>
<li><p>旧首新尾对比：匹配成功会将旧开始子节点移动到真实DOM中目前可供选择位置的最后，因为不能影响到已经patch好的子节点位置，然后移除待匹配的旧节点列表中的开始子节点和新节点列表中的结束子节点；</p>
</li>
<li><p>旧尾新首对比：匹配成功会将旧结束子节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配的旧节点列表中的结束子节点和新节点列表中的开始子节点；</p>
</li>
<li><p>如果上面四种没有匹配成功会分成两种情况：</p>
<ul>
<li>如果新旧子节点都存在key，会根据旧节点的key生成一张hash表，用S的key与hash表做匹配，判断是否时为sameVNode。<ol>
<li>匹配成功：将匹配成功的节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配旧节点中已经匹配到S的key的节点和待匹配新节点中的S；</li>
<li>匹配失败：将S生成真实DOM节点，插入到目前可供选择位置的最前，也就是oldS的位置，然后然后移除待匹配新节点中的S。</li>
</ol>
</li>
<li>如果没有key，将直接将遍历待匹配旧节点列表。<ol>
<li>匹配成功：将匹配成功的节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配旧节点中已经匹配到S的节点和待匹配新节点中的S；</li>
<li>匹配失败：将S生成真实DOM节点，插入到目前可供选择位置的最前，也就是oldS的位置，然后然后移除待匹配新节点中的S。</li>
</ol>
</li>
</ul>
<p>⚠️ 常见场景解析：</p>
<ul>
<li><p>v-for的时候设置key，就是为了如果首首、尾尾、首尾、尾首这四种匹配方式没匹配到的时候，可以使用key来更快地寻找可复用的节点，而不是只能用遍历的方式。</p>
</li>
<li><p>不能用index索引来做key的原因也是这个，因为用index索引来做key，并不能找到想要复用的旧节点，甚至可能会导致一个子节点都复用不了，起到负面作用。</p>
<p>举个🌰：一个数组长度是偶数的数组用index做key，被反序后，会给每一个子节点匹配到一个错误的不可复用的子节点，使diff的效率比没加key更低。</p>
</li>
</ul>
</li>
<li><p>循环上面的过程，不断的将待匹配节点列表向内部收缩。当待匹配的新旧节点列表有一个先被清空的话，将执行下面判断。</p>
<p>⚠️ 这里说的待匹配列表只是为了帮助理解来提出的一个概念，并没有一个真实的变量来存储这个待匹配列表。真实在数组中描述待匹配列表，是通过移动开始节点和结束节点的指针位置来实现。</p>
<ol>
<li>待匹配的旧节点列表被清空，也就是oldStartIdx &gt; oldEndIdx，说明旧节点都被patch了，还有新节点没被处理到，批量新增待匹配的新节点；</li>
<li>待匹配的新节点列表被清空，也就是newStartIdx &gt; newEndIdx，说明新节点都被patch了，还有多余的旧节点没被处理到，批量删除待匹配的旧节点。</li>
</ol>
</li>
</ol>
<h6 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h6><p>完成这一些复杂的匹配，就是为了更快更多地复用DOM的旧节点，因为DOM节点的创建开销是很大的。其实更快和更多是矛盾的，Vue找到了一个平衡点，比较只会在同层级进行, 不会跨层级。</p>
<h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><h5 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h5><p>父子组件在加载的时候，生命周期执行的顺序为：</p>
<p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted。</p>
<p>下面从首次渲染的流程角度，来分析为什么是这个顺序。</p>
<p>首次渲染时，父组件render生成父组件的VDOM，然后会执行父组件的patch方法，目的是将VDOM渲染成DOM。</p>
<p>在执行父组件patch方法解析到子组件VNode的时候，子组件VNode是被父组件的render函数生成的组件类型的VNode。在生成组件类型的组件过程中，完成了构造子类构造函数、安装组件钩子函数和实例化VNode，生成的子组件是没有children的，这个时候不知道子组件的细节。</p>
<p>patch到子组件VNode时，会触发子组件生命周期中的init hook，在init hook中开始对子组件进行挂载，将子组件当作一个新的Vue实例，重新进行初始化、render生成VDOM，然后执行子组件的patch。</p>
<p>解析子组件VNode这个过程，以深度优先的算法，将所有的子孙组件挂载到根实例上。有子组件就先完成子组件的完整挂载过程，等子组件完成挂载后再回到父组件完成父组件的挂载。从这个逻辑来理解，上面的生命周期执行顺序就很好理解了。</p>
<p>首次渲染patch过程比较简单，就是简单的插入，因为旧节点为空。</p>
<p>完成patch之后 ，将更新后的VNode数据赋值给oldVNode。</p>
<h5 id="数据更新的时候"><a href="#数据更新的时候" class="headerlink" title="数据更新的时候"></a>数据更新的时候</h5><p>数据更新触发渲染watcher更新的时候，会重新生成render函数，生成新的VNode，供patch方法为旧DOM打补丁使用。即使数据更新发生在很多组件上，每次执行渲染watcher更新，重新patch的时候关注的都只是当前组件。</p>
<p>⚠️ 每个组件都有自己的渲染watcher。</p>
<p>数据更新时patch过程就会相对复杂，会更充分使用到diff算法的细节。oldVNode就是上次渲染时的VNode，VNode就是本次重新生成的VNode，通过diff算法，一边一边比较一边给真实的DOM打补丁。</p>
<p>完成patch之后 ，将更新后的VNode数据赋值给oldVNode。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/11/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Vue2.x的render方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-11 09:37:56 / Modified: 09:41:44" itemprop="dateCreated datePublished" datetime="2021-09-11T09:37:56+08:00">2021-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2021/09/11/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的render方法" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/11/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/11/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>render方法将Vue实例渲染成一个虚拟Node，在生成VNode的时候完成了渲染watcher的依赖的收集。</p>
<p>patch方法将VNode转换为真正的DOM节点。</p>
<h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h4><p>在Vue实例挂载的时候，执行render方法来生成VNode。而在开发的时候，开发者大多数情况并不是自己手写的render函数，而是写的template模版或者el。在mounted的方法中，会将template模版编译成render方法，如果是el会多一个步骤，得先从el中提取出template模版。</p>
<h4 id="本集看点"><a href="#本集看点" class="headerlink" title="本集看点"></a>本集看点</h4><h5 id="render渲染VNode主要步骤"><a href="#render渲染VNode主要步骤" class="headerlink" title="render渲染VNode主要步骤"></a>render渲染VNode主要步骤</h5><ol>
<li><p>将children参数规范化：由于生成VNode的参数中children必须是VNode类型的，而下面几种情况下children不符合条件，所以在根据参数实例化VNode之前需要将children规范化成一个类型为VNode的Array。</p>
<ul>
<li><p>render函数是编译生成的，理论上编译生成的children已经是VNode类型的，但是当组件是函数式组件时，返回的是一个数组而不是一个根结点，所以需要用Array.prototype.concat方法将整个children数组打平，让深度只有一层。</p>
<p>⚠️只有这一种情况，调用simpleNormalizeChildren方法来实现children规范化。</p>
</li>
<li><ol>
<li>render函数是用户手写的，当children只有一个基础类型节点的时候，会调用createTextVNode方法创建一个文本节点的VNode；</li>
<li>render函数是手写的，当编译slot或者v-for的时候。</li>
</ol>
<p>⚠️只有这两种情况，调用normalizeChildren方法来实现children规范化。</p>
</li>
</ul>
</li>
<li><p>创建VNode实例</p>
<p>为每一个html标签创建一个VNode，顺序是先子后父，从上到下。可以理解成按照标签闭合的顺序，依次创建VNode，一个template模版中的根标签生成的就是当前组件的VNode树，也称为VDOM。</p>
<p>对tag进行判断，创建不同类型的VNode：</p>
<ul>
<li>如果是字符串类型且是内置的节点，直接创建普通VNode;</li>
<li>如果是字符串类型且是已注册的组件名，则通过createComponent方法创建一个组件类型的VNode;</li>
<li>如果是字符串类型，又不是上面两种情况，创建一个未知标签的VNode;</li>
<li>如果是组件类型，则通过createComponent方法创建一个组件类型的VNode。</li>
</ul>
</li>
</ol>
<h5 id="创建组件类型VNode主要步骤"><a href="#创建组件类型VNode主要步骤" class="headerlink" title="创建组件类型VNode主要步骤"></a>创建组件类型VNode主要步骤</h5><p>render渲染VNode可能会生成3种类型的VNode：</p>
<ol>
<li>普通类型VNode;</li>
<li>未知标签VNode;</li>
<li>组件类型VNode。</li>
</ol>
<p>因为前面两种都比较简单，这里着重分析组件类型VNode。通过createComponent方法将组件渲染成VNode主要做了3个事情：</p>
<ol>
<li><p>构造子类构造函数：开发者在写组件的时候，通常都是创建一个普通的对象，Vue内部使用Vue.extend将这个普通对象做了扩展，使这个对象可以像Vue实例一样可以完成初始化、挂载、渲染等一系列功能。</p>
<p>Vue.extend的作用是构造一个Vue的子类，使用一种非常经典的原型继承的方式把一个纯对象转换成了一个继承于Vue的构造器Sub并返回，然后对Sub对象本身扩展一些属性，如扩展options、添加全局API，并且对配置做一些初始化工作。</p>
<p>最后对这个Sub构造函数做了缓存，避免多次执行Vue.extend的时候对同一个子组件重复构造。在执行父组件patch方法解析到组件VNode的时候，会触发子组件生命周期中的init hook，在init hook中开始对子组件进行挂载，再走到子组件初始化逻辑。</p>
</li>
</ol>
<ol start="2">
<li><p>安装组件钩子函数：将组件特有的几个钩子和Vue实例的生命周期钩子合并。</p>
<p>在实例化Vue的时候，Vue的挂载是在初始化完成的时候，这个是一个同步的事件，有一个固定的地方可以执行这块逻辑，不需要钩子函数来回调Vue的挂载操作。</p>
<p>而子组件的挂载时机，是在父组件patch的过程中。子组件为了更好的管理自己的生命周期，添加了init、prepatch、insert和destroy四个生命周期钩子，分别对应初始化、更新、挂载完成、销毁。</p>
<p>在父组件VNode执行执行patch的时候会执行上面的钩子函数，这就可以实现组件的渲染。这里需要注意的一点是Vue实例原有的几种生命钩子是可以正常使用的，如mounted钩子函数会在insert钩子执行的时候被调用。</p>
</li>
</ol>
<ol start="3">
<li><p>实例化VNode：实例化一个VNode，不过需要注意的是组件的VNode是没有children的。因为父组件render方法中，是看不到子组件内部结构的，只会为子组件生成一个组件VNode。</p>
<p>父组件render方法生成VDOM之后，会执行到patch方法，在patch过程中会将子组件当作一个新的Vue实例，重新进行初始化、render生成VDOM，在这个子组件render方法生成的VDOM中，才会有children。</p>
<p>也就是说render方法在解析子组件的时候，只会将子组件生成一个组件VNode，不会关心子组件是否有子组件，子组件是否有子组件，这个事情由子组件来关心。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/" class="post-title-link" itemprop="url">Vue2.x的数组响应式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-07 10:25:01" itemprop="dateCreated datePublished" datetime="2021-09-07T10:25:01+08:00">2021-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-08 15:35:37" itemprop="dateModified" datetime="2021-09-08T15:35:37+08:00">2021-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2021/09/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的数组响应式" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="数组响应式的限制"><a href="#数组响应式的限制" class="headerlink" title="数组响应式的限制"></a>数组响应式的限制</h4><p>Vue对数组响应式的处理可以分为两个方面来理解：</p>
<ol>
<li>对数组项的以下7个操作方法做了重写，当数组使用下面方法改变了数组的值，Vue会派发更新通知依赖数组的watcher。<ul>
<li>push</li>
<li> pop</li>
<li> shift</li>
<li> unshift</li>
<li> splice</li>
<li> sort</li>
<li> reverse</li>
</ul>
</li>
<li>数组项的值如果是对象，会对对象属性进行数据劫持实现响应式，完全走的就是对普通对象属性进行依赖收集，派发更新那一套流程。</li>
</ol>
<p>Vue中不能检测以下数组的变动：</p>
<ol>
<li>利用索引直接设置一个数组项；</li>
<li>修改数组的长度。</li>
</ol>
<p>Vue中的数据响应式，实际上是通过对对象属性进行的数据劫持，而且无论是数组还是对象，响应式都是在初始化的时候完成的。Vue希望开发者可以提前声明所有的响应式属性，可以让响应式更可控。</p>
<ol>
<li><p>数组项并不是一个对象的属性，在Vue中是不具有响应式的，在对这个数组项直接赋值的时候，数组值会改变，但并不会触发数组的setter方法。</p>
<p>⚠️如果这个数组项的值是一个对象，那这个对象里面的属性值是响应式的。</p>
</li>
<li><p>修改数组的长度，数组值会改变，但并不会触发数组的setter方法。新数组中只有数组项里还存在的对象属性是响应式的。</p>
</li>
</ol>
<p>与其说Vue不能检测上面两种方式的变化，不如说Vue不想检测，尤大给的原因是性能代价和获得的用户体验收益不成正比。其实也好理解，对数据项直接赋值和修改数组的长度这两种方式都太不可控了。</p>
<h4 id="数组响应式的实现"><a href="#数组响应式的实现" class="headerlink" title="数组响应式的实现"></a>数组响应式的实现</h4><p>在对数组类型的数据进行响应式处理之前，先往数组上绑定了数原型上有的一些方法和属性。这些方法和属性中有7个方法是被Vue做了重写的。因为这7个方法会改变数组本身的值，而Vue根本就没有对数组项这个维度进行响应式处理，所以不会触发数组的setter方法。</p>
<p>为了处理这种情况，使数组在用的这7种方法改变值的时候会触发依赖更新，Vue将这几个方法做了一个重写。</p>
<p>其中pop、shift、sort、reverse四个方法，因为没有添加数组项，所以重写的步骤很简单，就是执行方法、手动派发更新和返回方法的结果值。</p>
<p>而push、unshift和splice方法因为添加了数据项，所以重写的步骤多了一项，简单来讲就是执行方法、将新增的数据项进行响应式处理、手动派发更新和返回方法的结果值。</p>
<p>往目标数组中绑定这些方法和属性时，根据浏览器是否支持__proto__，分为了两种处理方法。</p>
<ol>
<li>支持__proto__：调用protoAugment方法通过原型式继承的方式，将目标数组的原型指向改造后的数组的实例，这个实例中既有数组的所有属性和方法，又有重写了的7个方法，这种方式是将方法和属性绑定在目标的原型链上。</li>
<li>不支持__proto__：调用copyAugment方法，通过def函数，遍历改造后的数组实例，将方法和属性挂在到目标数组的属性上。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>出于对性能的考虑，没有直接用Object.defineProperty去监听数组，但是需要知道Object.defineProperty是具备这个能力的。Vue2.x通过对常见的7种方法进行了重写，来实现对数组项的监听。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/07/Vue2.x%E7%9A%84Virtual%20DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/07/Vue2.x%E7%9A%84Virtual%20DOM/" class="post-title-link" itemprop="url">Vue2.x的Virtual DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-07 08:50:49" itemprop="dateCreated datePublished" datetime="2021-09-07T08:50:49+08:00">2021-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-13 17:28:50" itemprop="dateModified" datetime="2021-09-13T17:28:50+08:00">2021-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2021/09/07/Vue2.x%E7%9A%84Virtual%20DOM/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的Virtual DOM" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/07/Vue2.x%E7%9A%84Virtual%20DOM/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/07/Vue2.x%E7%9A%84Virtual%20DOM/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>浏览器中的DOM的设计是非常复杂的，当我们频繁的去做DOM更新的时候，会产生一定的性能问题。</p>
<p>而Virtual DOM就是一个用js对象去描述一个DOM节点，对Virtual DOM的操作代价会少很多。</p>
<p>这个设计在react中也有用到，在Vue中Virtual DOM是用VNode这么一个Class去描述的，借鉴了⼀个开源库 snabbdom 的实现，然后加⼊了⼀些 Vue.js 特⾊的东⻄。</p>
<p>⚠️ 使用了虚拟DOM不一定会比直接渲染真实DOM快。举个🌰：一些很明显直接替换DOM的情况下，用虚拟DOM+diff算法，明显是会更慢的。所以严谨的说法是，在复杂视图情况下，使用虚拟DOM+diff算法可以找到DOM树变更的地方，复用之前的DOM，是可以减少DOM的操作使渲染速度更快的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/07/Vue2.x%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/07/Vue2.x%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Vue2.x的渲染过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-07 08:47:39 / Modified: 08:48:47" itemprop="dateCreated datePublished" datetime="2021-09-07T08:47:39+08:00">2021-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2021/09/07/Vue2.x%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的渲染过程" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/07/Vue2.x%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/07/Vue2.x%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>new Vue 之后执行一系列的初始化操作，如合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化inject、props、method、data、computed、watch、privide等等。</p>
<p>初始化完成之后，对Vue实例进行挂载。挂载时会判断是否有render函数，如果是el和template转换成render方法，执行render方法会生成VNode tree，也就是VDOM。</p>
<p>最后再调用patch方法，将VNode渲染成DOM并完成挂载，实际上整个渲染过程调用的就是原生的DOM API。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">浏览器的进程和线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-06 11:37:22" itemprop="dateCreated datePublished" datetime="2021-09-06T11:37:22+08:00">2021-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-07 08:17:35" itemprop="dateModified" datetime="2021-09-07T08:17:35+08:00">2021-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          
            <span id="/2021/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="浏览器的进程和线程" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>进程有单独的属于自己的内存空间，一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。一个进程的内存空间是共享的，每个线程都可用这些共享内存。</p>
<p>翻译翻译：</p>
<p>如果把进程比作工厂的话，线程就是工厂的工人，工厂有单独的专属于自己的工厂资源，工人可以共享工厂资源。</p>
<h4 id="多进程的好处"><a href="#多进程的好处" class="headerlink" title="多进程的好处"></a>多进程的好处</h4><p>在同一个时间内，同一个计算机系统中允许两个或两个以上的进行处于运行状态，进程之间丝毫不会互相干扰，可以同时做多个事情。</p>
<h4 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h4><p>程序中包含多个执行流，即在同一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p>
<h4 id="常见进程"><a href="#常见进程" class="headerlink" title="常见进程"></a>常见进程</h4><p>以chrome浏览器为例，来分析一下浏览器的进程。</p>
<p><img src="https://raw.githubusercontent.com/whpuEdison/blog/master/static/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B.png" alt="img"></p>
<p>上图是浏览器只打开一个百度的标签页时，任务管理器的状态。主要可以关注以下几个进程。</p>
<ol>
<li>浏览器进程：负责协调、主控其他进程。<ul>
<li>负责各个页面的管理，创建和销毁其他进程；</li>
<li>负责浏览器界面显示与用户交互，如前进、后退等；</li>
</ul>
</li>
<li>GPU进程：使用初衷是为了实现3D CSS的效果，后面随着网页、Chrome的UI界面都选择用GPU来绘制，使得GPU成为了浏览器普遍的需求。</li>
<li>Network Service：网络进程，主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面。</li>
<li>Storage Service：控制文件读写的存储线程；</li>
<li>Audio Service：音频进程；</li>
<li>渲染进程：核心任务是将HTML、CSS和javascript转换为用户可以与之交互的网页，排版引擎Blink和javascript引擎V8都是运行在该进程中。默认情况下，Chrome会为每个Tab标签创建一个渲染进程，当进程数达到一定的界限后，Chrome会将访问同一个网站的tab都放在一个进程里面跑。处于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程中主要包含以下线程：<ul>
<li>主线程 Main thread：对几个常驻线程的调用，执行大多数的代码。</li>
<li>工作线程 Worker thread：web worker和service worker相关的代码由该进程处理。</li>
<li>光栅线程 Raster thread：将文档结构、元素的样式、元素的几何位置以及绘画顺序这些信息转化为显示器的像素的过程叫做光栅化。</li>
<li>合成线程 Compositor thread：将页面分成若干层，分别进行光栅化，光栅化之前合成线程需要将页面的一层切分成一块又一块小图块，光栅线程会栅格化每个图块并将它们储存在GPU的内存中。最后在合成线程中合并成一个页面。当页面的层超过一定的数量后，层的合成操作要比每个帧中光栅化页面的一小部分还要慢。</li>
</ul>
</li>
<li>插件进程：虽然图上没有，也可以了解一下。主要负责插件的运行，用来保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ol>
<p>⚠️Network Service、Storage Service和Audio Service这些服务本来是在浏览器进程里面的，后来将这些模块拆分为了一个个不同的服务，这个过程也叫做Chrome服务化。服务化之后，这些功能既可以放在不同的进程里运行，也可以合并为一个单独的进程运行。</p>
<p>这样做主要是为了让Chrome在不同性能的硬件上有不同的表现。当Chrome运行在一些性能比较好的硬件时，浏览器进程香港的服务会放在不同的进程中运行来提高系统的稳定性。如果硬件性能不好，这些服务就被放在同一个进程里面执行来减少内存的占用。</p>
<h4 id="渲染进程中的线程"><a href="#渲染进程中的线程" class="headerlink" title="渲染进程中的线程"></a>渲染进程中的线程</h4><p>渲染进程也称为浏览器内核，浏览器内核通过取得页面内容，整理信息、计算组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p>
<p>浏览器内核是多线程，在内核控制下各个线程相互配合，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI渲染线程（有且只有一个）</li>
<li>JavaScript引擎线程（有且只有一个）</li>
<li>定时触发器线程（多个）</li>
<li>事件触发线程</li>
<li>异步http请求线程（多个）</li>
</ul>
<h5 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h5><p>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。当界面需要重绘或重排时，会执行该线程。</p>
<p>⚠️渲染线程跟JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起。当任务队列空闲时，才会执行GUI渲染。互斥的原因是因为，JS是可以操作DOM的，边操作边渲染会出现问题，js被设计成单线程也是这个原因。</p>
<h5 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h5><p>同步任务和异步任务都由该线程执行。如果JS引擎执行脚本的时间过长，将导致页面渲染阻塞。</p>
<h5 id="定时器触发线程"><a href="#定时器触发线程" class="headerlink" title="定时器触发线程"></a>定时器触发线程</h5><p>主要负责执行异步定时器一类的函数，如setTimeOut、setInterval。主线程按顺序执行代码时，遇见定时器，会将定时器交给该线程处理。当计时完毕后，通过事件触发线程将技术完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</p>
<h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><p>主要负责将准备好的事件交给JS引擎线程执行。也就是将已经准备好的异步回调函数添加到任务队列的队尾。</p>
<h5 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h5><p>负责执行异步请求一类的函数，如： Promise、axios、ajax等。主线程按顺序执行代码时，遇到异步请求，会将函数交给该线程处理。当监听到状态码变更，如果有回调函数，事件触发线程将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/03/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/03/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Node的事件循环机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-03 18:39:41" itemprop="dateCreated datePublished" datetime="2021-09-03T18:39:41+08:00">2021-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-06 09:06:58" itemprop="dateModified" datetime="2021-09-06T09:06:58+08:00">2021-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
                </span>
            </span>

          
            <span id="/2021/09/03/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="Node的事件循环机制" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/03/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/03/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Node中的Event Loop和浏览器中的是完全不相同的东西。Node采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv。libuv是一个事件驱动的跨平台抽象层，封装了不同操作系统的一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p>
<h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>V8引擎解析js脚本，解析后的代码调用Node API。libuv库负责Node API的执行，将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的返回结果返回给V8引擎，再由V8引擎将结果返回给用户。</p>
<h4 id="事件循环的阶段顺序"><a href="#事件循环的阶段顺序" class="headerlink" title="事件循环的阶段顺序"></a>事件循环的阶段顺序</h4><p>输入数据阶段 incoming data -&gt; 轮询阶段 poll -&gt;  检查阶段 check -&gt; 关闭事件回调阶段 close callback -&gt; 定时器检测阶段 timer -&gt;  I/O事件回调阶段 I/O callbacks -&gt; 闲置阶段 idle,prepare -&gt; 轮询阶段 poll …</p>
<h4 id="六大阶段概述"><a href="#六大阶段概述" class="headerlink" title="六大阶段概述"></a>六大阶段概述</h4><ul>
<li>定时器检测阶段 timer：执行timer的回调，即setTimeout、setInterval里面的回调函数；</li>
<li>I/O事件回调阶段 I/O callbacks：执行上一轮循环中未被执行的一些I/O回调；</li>
<li>闲置阶段 idle, prepare：仅系统内部使用；</li>
<li>轮询阶段 poll：检索新的I/O事件，执行与I/O相关的回调；</li>
<li>检查阶段 check：setImmediate()回调函数在这里执行；</li>
<li>关闭事件回调阶段 close callback：一些关闭的回调函数，如socket.on(‘close’, …)。</li>
</ul>
<p>⚠️每个阶段都有一个先进先出队列来执行回调。通常情况下，当事件循环进入给定的阶段后，将执行该阶段的任何操作，然后执行该阶段队列中的回调。当该队列执行完毕或达到最大回调限制时，事件循环将移动到下一阶段。</p>
<h4 id="三大阶段详述"><a href="#三大阶段详述" class="headerlink" title="三大阶段详述"></a>三大阶段详述</h4><p>日常开发中绝大部分的异步任务都是在poll、check、timer这三个阶段，重点分析一下。</p>
<h5 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h5><p>timer阶段会执行setTimeout、setInterval里面的回调函数，并且是由poll阶段控制的。在Node中定时器指定的时间也不是准确时间，只能是尽快执行。</p>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>setImmediate()回调函数在这里执行。</p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>poll阶段是一个至关重要的阶段，执行逻辑相对复杂，具体流程如下。</p>
<p>在这一阶段中，系统会做两件事情：</p>
<ol>
<li>回到timer阶段执行回调：设定了timer且poll队列为空，如果有timer超时，则会回到timer阶段；</li>
<li>执行I/O回调（没满足上面的条件就会走下面流程）：<ul>
<li>如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制；</li>
<li>如果poll队列为空时，也有两种情况：<ul>
<li>如果有setImmediate回调需要执行，poll阶段会停止并且进入到check阶段执行回调；</li>
<li>如果没有setImmediate回调需要执行，会等待回调被加入队列中并立即执行回调。这里有个超时时间设置，防止一直等待下去。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="分析差别"><a href="#分析差别" class="headerlink" title="分析差别"></a>分析差别</h4><p>Node中的事件循环和浏览器的事件循环，差别就在于浏览器中事件循环中异步任务只分为了宏任务和微任务，他们执行的是同属于一个阶段的，简单理解为渲染之前的阶段。而Node中的不同的宏任务会有不同的执行阶段，且微任务的执行时机跟Node的版本还有关系。</p>
<h5 id="Node中宏任务和微任务"><a href="#Node中宏任务和微任务" class="headerlink" title="Node中宏任务和微任务"></a>Node中宏任务和微任务</h5><h6 id="宏任务-macro-task"><a href="#宏任务-macro-task" class="headerlink" title="宏任务 macro-task"></a>宏任务 macro-task</h6><ul>
<li>setTimeout：timers阶段执行；</li>
<li>setInterval：timers阶段执行；</li>
<li>setImmediate：check阶段执行；</li>
<li>script 整体代码：执行同步代码，将不同类型的异步任务添加到任务队列；</li>
<li>I/O 操作：poll阶段执行。</li>
<li>…</li>
</ul>
<h6 id="微任务-micro-task"><a href="#微任务-micro-task" class="headerlink" title="微任务 micro-task"></a>微任务 micro-task</h6><ul>
<li>process.nextTick：与普通的微任务有区别，在微任务队列执行之前执行；</li>
<li>Promise.then;</li>
<li>…</li>
</ul>
<h5 id="版本差异总结"><a href="#版本差异总结" class="headerlink" title="版本差异总结"></a>版本差异总结</h5><p>node11之前，每一个event loop阶段完成后都会先清空nextTick队列，再清空微任务队列。</p>
<p>node11之后，process.nextTick是微任务的一种，但还是执行顺序优先于Promise.then。在异步任务的执行方面，已经在向浏览器看齐，最大的改变是微任务的执行时机发生变化了。当执行完一个宏任务时，生成的微任务会在这个宏任务出队列的时候立即执行，而不是等到一个event loop阶段再去执行。</p>
<p>⚠️虽然node11之后，异步方法的执行方面已经在向浏览器看齐了，但是不同的宏任务还是位于不同的阶段去执行，这个跟浏览器还是很大差别的。</p>
<h6 id="举几个🌰"><a href="#举几个🌰" class="headerlink" title="举几个🌰"></a>举几个🌰</h6><ol>
<li>微任务执行时机</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;promise resolve&#x27;</span>))</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;next tick1&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;next tick2&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timeout3&#x27;</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timeout4&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// node11之前：timeout1 -&gt; timeout2 -&gt; timeout3 -&gt; timeout4 -&gt; next tick1 -&gt; next tick2 -&gt; promise resolve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node11之后：timeout1 -&gt; next tick1 -&gt; promise resolve -&gt; timeout2 -&gt; next tick2 -&gt; timeout3 -&gt; timeout4</span></span><br></pre></td></tr></table></figure>

<p>过程分析：</p>
<p>node11之前，在check阶段执行setImmediate的时候遇到的微任务都会先放入微任务队列，等check阶段所有的setImmediate执行完成之后，在进入关闭事件回调阶段 close callback之前，会讲所有的微任务清空。</p>
<p>node11之后，在check阶段执行setImmediate的时候遇到的微任务都在当前的宏任务执行完成之后，马上清空该宏任务生成的微任务。等微任务清空后，再去执行下一个宏任务。</p>
<ol start="2">
<li>setTimeout 和 setImmediate</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> <span class="title">immediate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行结果：结果不固定</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码来说，setTimeout可能执行在前，也可能执行在后。首先科普一下，setTimeout(fn, 0) === setTimeout(fn, 1)，这个是源码决定的。</p>
<p>因为进入事件循环也是需要时间的，如果在进入时间循环的准备阶段花费了大于1ms的时间，那么此时就成了一个timer超时且poll队列为空的状态，会回到timer阶段执行setTimeout回调。</p>
<p>如果进入时间循环的准备阶段花费了小于1ms的时间，不满足timer超时且poll队列为空的状态，就会还是处于poll阶段执行I/O回调。由于poll队列为空，且有setImmediate回调，就直接跳转到check阶段执行immediate回调函数。</p>
<ol start="3">
<li>异步I/O回调中的setTimeout 和 setImmediate</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.readFile(<span class="string">&#x27;./reptileServer.js&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">    setImmediate(<span class="function"><span class="keyword">function</span> <span class="title">immediate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果：immediate -&gt; timeout</span></span><br></pre></td></tr></table></figure>

<p>这个🌰跟上面看似只有细微差别，实际上会有完全不同的执行结果，会稳定先执行setImmediate回调。因为在I/O回调生成setTimeout和setImmediate宏任务时，poll队列不为空，所以不管timer是否超时都不会进入到timers阶段。等队列为空时，会直接到check阶段执行setImmediate回调。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">浏览器的事件循环机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-03 18:39:27" itemprop="dateCreated datePublished" datetime="2021-09-03T18:39:27+08:00">2021-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-05 10:12:24" itemprop="dateModified" datetime="2021-09-05T10:12:24+08:00">2021-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          
            <span id="/2021/09/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="浏览器的事件循环机制" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在研究浏览器的事件循环机制之前，先了解几个关键词。</p>
<h5 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h5><p>同步任务都在主线程上执行，形成一个执行栈，可以认为是一个存储函数调用的栈结构，遵循后进先出的原则。</p>
<h5 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h5><p>只要异步任务有了运行结果，就在任务队列中放置一个事件。异步任务分为宏任务macro-task和微任务micro-task，在es6中宏任务被称为task，微任务被称为jobs。宏任务会放置在宏任务队列，微任务会放置在微任务队列。</p>
<h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><p>浏览器常见的宏任务：script（整体代码）、setTimeout、setInterval、setImmediate、UI render。</p>
<h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><p>浏览器常见的微任务：Promise.then、Async/Await、MutationObserver（h5新特性）。</p>
<h4 id="事件循环过程"><a href="#事件循环过程" class="headerlink" title="事件循环过程"></a>事件循环过程</h4><ol>
<li>开始的时候执行栈和微任务队列为空，宏任务队列有且只有一个script脚本（整体代码）；</li>
<li>执行栈中同步任务执行完毕后，系统会读取任务队列。只有宏任务队列有一个script脚本（整体代码）的异步任务，将该宏任务推入执行栈；</li>
<li>执行过程中，遇到同步代码直接执行，生成宏任务添加到宏任务队列，生成微任务添加到微任务队列。等同步代码执行玩后，script脚本被移除宏任务队列，这个就是宏任务的执行和出队列的过程；</li>
<li>执行完一个宏任务之后，接下来就是处理上一个宏任务执行过程中产生的微任务队列，逐个执行微任务并将任务出队，直到队列被清空。需要注意的是宏任务的执行和出队是一个一个执行的，而微任务的执行和出队是一队一队的；</li>
<li>执行渲染操作，更新界面；</li>
<li>上面过程循环往复，知道宏任务队列和微任务队列都清空。</li>
</ol>
<h4 id="举几个🌰"><a href="#举几个🌰" class="headerlink" title="举几个🌰"></a>举几个🌰</h4><h5 id="宏任务和微任务执行顺序"><a href="#宏任务和微任务执行顺序" class="headerlink" title="宏任务和微任务执行顺序"></a>宏任务和微任务执行顺序</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行顺序：Promise1 -&gt; setTimeout1 -&gt; Promise2 -&gt; setTimeout2</span></span><br></pre></td></tr></table></figure>

<p>执行流程分析：</p>
<p>整体代码是一个宏任务，将宏任务压入执行栈。执行过程中先生成了一个微任务简称为Promise1添加到微任务队列，后面又生成一个宏任务简称setTimeout1添加到宏任务队列。执行完这个整体代码的宏任务之后，将这个宏任务出队列。</p>
<p>接下来就是执行上一个宏任务（整体代码）生成的微任务队列，开始执行Promise1。执行微任务p1的时候生成一个宏任务setTimeout2，将宏任务setTimeout2添加到宏任务队列，此时宏任务队列有setTimeout1和setTimeout2。</p>
<p>微任务队列执行完成，执行宏任务队列最前面的宏任务setTimeout1，因为队列的原则是先进先出。在执行宏任务setTimeout1的时候，生成了微任务Promise2。执行完宏任务setTimeout1，将这个宏任务出队列。</p>
<p>接下来就是执行上一个宏任务（setTimeout1）生成的微任务队列，开始执行Promise2。执行完微任务列队，再来执行宏任务里的唯一的一个宏任务setTimeout2。执行完宏任务setTimeout2，将这个宏任务出队列。此时宏任务和微任务队列都已清空，结束当前事件循环。</p>
<p>⚠️微任务执行完也是会出列的。</p>
<h5 id="Async-Await执行顺序"><a href="#Async-Await执行顺序" class="headerlink" title="Async/Await执行顺序"></a>Async/Await执行顺序</h5><blockquote>
<p>科普知识：await下面的代码怎么执行？</p>
<p>如果await后面跟同步函数的调用。相当于直接将await下面的代码注册为一个微任务，可简单理解为promise.then(await下面的代码)。然后跳出async函数，执行其他代码。</p>
<p>如果await后面跟一个异步函数的调用，当await之后的函数中同步任务被执行，异步任务被添加到任务队列之后，直接跳出async函数，执行剩下代码，等剩下代码同步任务被执行，异步代码被添加到任务队列之后，再来将await下面的代码注册为一个微任务。</p>
</blockquote>
<h6 id="await后面跟同步函数的调用"><a href="#await后面跟同步函数的调用" class="headerlink" title="await后面跟同步函数的调用"></a>await后面跟同步函数的调用</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果： script start -&gt; async2 end -&gt; Promise -&gt; script end</span></span><br><span class="line"><span class="comment">// -&gt; async1 end -&gt; promise1 -&gt; promise2 -&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行流程分析：</p>
<ol>
<li>整体代码是个宏任务压入执行栈执行，执行同步任务打印’script start’；</li>
<li>执行async1时，await后面的函数可以当作同步任务执行，打印’async2 end’；</li>
<li>因为async1中的await后面的函数并不是异步函数，所以可以直接将await下面的代码生成为一个微任务，并添加到微任务队列；</li>
<li>代码往下执行生成一个setTimeout宏任务，将宏任务添加到宏任务队列；</li>
<li>代码往下执行创建一个Promise实例。注意创建Promise实例时，参数是一个是以同步的方式执行的函数，直接打印’Promise’；</li>
<li>代码往下执行生成promise1和promise2两个微任务，并按顺序加入微任务队列；</li>
<li>执行同步任务打印’script end’，将全部代码这个宏任务出列；</li>
<li>开始执行上一个宏任务生成的微任务队列，此时微任务队列里是三个微任务，分别是await下面的代码生成的微任务、promise1和promise2，依次执行出队列。结果是按顺序打印’async1 end’、’promise1’、 ‘promise2’；</li>
<li>执行完微任务队列后，此时宏任务队列只有一个setTimeout宏任务；</li>
<li>执行setTimeout宏任务，打印’setTimeout’，结束宏任务并将宏任务出列。此时宏任务和微任务队列都已清空，结束当前事件循环。</li>
</ol>
<h6 id="await后面跟异步函数的调用"><a href="#await后面跟异步函数的调用" class="headerlink" title="await后面跟异步函数的调用"></a>await后面跟异步函数的调用</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果： script start -&gt; async2 end -&gt; Promise -&gt; script end</span></span><br><span class="line"><span class="comment">//  -&gt; async2 end1 -&gt; promise1 -&gt; promise2 -&gt; async1 end -&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行流程分析（跟上个🌰的流程差别，主要是await后面的代码执行时机，具体是步骤2、3、8）：</p>
<ol>
<li>整体代码是个宏任务压入执行栈执行，执行同步任务打印’script start’；</li>
<li>执行async1时，await后面的函数可以当作同步任务执行。async2函数执行打印’async2 end’，生成一个微任务简称为Promise async2；</li>
<li>因为async1中的await后面的函数是异步函数，所以直接跳出了async1函数；</li>
<li>代码往下执行生成一个setTimeout宏任务，将宏任务添加到宏任务队列；</li>
<li>代码往下执行创建一个Promise实例。注意创建Promise实例时，参数是一个是以同步的方式执行的函数，直接打印’Promise’；</li>
<li>代码往下执行生成promise1和promise2两个微任务，并按顺序加入微任务队列；</li>
<li>执行同步任务打印’script end’，再回到async1函数中将await下面的代码生成为一个微任务，并添加到微任务队列。此时本轮宏任务执行就执行完了，将全部代码这个宏任务出列；</li>
<li>开始执行上一个宏任务生成的微任务队列，此时微任务队列里是三个微任务，分别是Promise async2、promise1、promise2和await下面的代码生成的微任务，依次执行出队列。结果是按顺序打印’async2 end1’、’promise1’、 ‘promise2’、’async1 end’；</li>
<li>执行完微任务队列后，此时宏任务队列只有一个setTimeout宏任务；</li>
<li>执行setTimeout宏任务，打印’setTimeout’，结束宏任务并将宏任务出列。此时宏任务和微任务队列都已清空，结束当前事件循环。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="马帅傅"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">马帅傅</p>
  <div class="site-description" itemprop="description">道阻且长,行则将至</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马帅傅</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'CvwUY722HB1rJt3XHzcbMEOc-gzGzoHsz',
      appKey     : 'vsP2YzUdTWIWI9gdYB9UhhUr',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
